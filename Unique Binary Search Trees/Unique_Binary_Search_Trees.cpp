/*
思路一 使用卡特兰数

0ms 100%

令h(0)=1,h(1)=1，catalan数满足递推式。h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (n>=2)
这个公式还可以更简单得化为h(n)=C(2n,n)/(n+1)

我们可以假设，如果采用中序遍历的话，根结点第k个被访问到，
则根结点的左子树有k-1个点、根结点的右指数有n-k个点。
k的取值范围为1到n。
讲到这里就很明显看得出是卡特兰数了

并且给定的节点是从1到n的，当左右节点个数确定的时候，根节点也就确定了

有了计算公式之后，这道题目看似很简单，但是其实有很多坑，如果直接递归去计算，结果超时
原因很明显，有大量的重复计算

这里如果直接使用简化版的组合公式去计算，c++会出现溢出的现象，unsigned long int也不行 使用double又会出现
与结果差1的情况

因此，这里使用动态规划的方式
*/

class Solution {
public:
    int numTrees(int n) {
        int *res = new int[n + 1]();

        res[0] = res[1] = 1;

        for (int i = 2; i <= n; i++)
        {
            for (int j = 0; j <= i - 1; j++)
            {
                res[i] += (res[j] * res[i - j - 1]);
            }
        }

        int temp = res[n];
        delete [] res;
        return temp;
    }
};